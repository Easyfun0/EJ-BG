---
layout: post
title:  "變數"
date:   2023-03-08
author: Easyfun
categories: Rust
cover:  "/assets/cover-thumb.png"
---


## 變數與可變性

Rust推動你能充分利用Rust提供的安全性和簡易並行性來寫程式的方法之一。

當一個變數是不可變的，只要有數值綁定在一個名字上，你就無法改變其值。


## 變數綁定

在Rust中我們會:

let a = "hello" ，同時稱作變數綁定

## 變數可變性
{% highlight rust %}

fn main() {
    let x = 1;
    println!("The value of x is: {}", x);
    x = 2;
    println!("The value of x is: {}", x);
}

{% endhighlight %}

執行後
```
error[E0384]: cannot assign twice to immutable variable `x`
 --> /Users/huangyingjie/Rprojects/new_demo/src/main.rs:4:5
  |
2 |     let x = 1;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 2;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
```

錯的原因是cannot assign twice to immutable x(無法對不可變的變數進行重複賦值)，因為我們想對不可變的x變數再次賦值。

在Rust中，可變性很簡單，只要在變數前加一個mut就可。

為了讓變數為可變，可改為:

{% highlight Rust %}

fn main(){
  let mut x = 1;
  printl!("The value of x is: {}",x);
  x = 2;
  println!("The value of x is: {}", x);
}

{% endhighlight %}

```
:!'/var/folders/mg/1r752ql131v0n4nfn43j2xdc0000gn/T/nvim.huangyingjie/mKXpmr/1/main'
The value of x is: 1
The value of x is: 2
```
### 使用下底線開頭忽略未使用變數

當你創建了一個變數卻未使用它，Rust會給你警告。但有時創建一個不會被使用的變數是有用的，比如正在設計一個原形或剛開始一個項目。這時你希望Rust不要警告未使用的變數，為此可以用下底線作為變數的開頭:

{% highlight rust %}

fn main(){
  let _x = 1;
  let y = 2;
}

{% endhighlight %}

> cargo run
  warning: unused variable: `y`
   --> src/main.rs:3:9
    |
  3 |     let y = 2;
    |         ^ help: if this is intentional, prefix it with an underscore: `_y`
    |
    = note: `#[warn(unused_variables)]` on by default

### 變數解構

在Rust 1.59後，我們可在賦值句的左式中使用元組,切片和結構體模式。
{% highlight rust %}

struct Struct {
  e:i32
}
fn main(){
  let (a,b,c,d,e);

  (a, b) = (1, 2);
  [c, .., d, _] = [1, 2, 3, 4, 5];
  Struct {e, .. } = Struct {e: 5};

  assert_eq!([1, 2, 3, 4, 5], [a, b, c, d, e]);
}

{% endhighlight %}

這方法跟之前的let保持了一致性，但是let會重新綁定，而這裡只是對之前綁定的變數進行再賦值。

需注意的是，使用 += 的賦值語句還不支持解構式賦值。

### 變數和常數之間的差異

常數(constant) 與不可變數一樣，常數也是綁定到一個常數名且不允許更改的值，但是常數和變數還是存在一些差異:




```
├── .git
├── .gitignore
├── Cargo.toml
└── src
    └── main.rs
```

## 運行方式

有兩種方式可以運行項目:

1.cargo run

2.手動編譯和運行項目

run運行後:
> cargo run

```
  Compiling new_demo v0.1.0 (/Users/huangyingjie/Rprojects/new_demo)

  Finished dev [unoptimized + debuginfo] target(s) in 2.62s

  Running `target/debug/new_demo`

Hello, world!
```

在這個狀態是debug模式，代碼的編譯速度會非常快，但運行的速度就慢了，在debug模式下，Rust編譯器不會做任何的優化，讓你的開發流程更加順暢。

高性能的方法:

🔍cargo run --release

🔍cargo build --realease

### Cargo check

cargo check是我們在程式碼開發過程中最常用指令，它可以快速的檢查一下程式碼能否編譯通過。因此該
命令速度會非常快，能節省大量的編譯時間。

> cargo check

    Checking new_demo v0.1.0 (/Users/huangyingjie/Rprojects/new_demo)

    Finished dev [unoptimized + debuginfo] target(s) in 2.23s

### Cargo.toml 和 Cargo.lock

Cargo.toml和Cargo.lock是cargo的核心文件，主要是基於兩者:

🪒 Cargo.toml是cargo特有的項目數據描述文件。它存了項目的所有原配置信息，如果Rust開發者希望Rust項目能夠依照期望的方式進行建構,測試和運行，那必須按照合理的方式構建Cargo.toml。

🪒 Cargo.lock文件是cargo工具根據同一項目的toml文件生成的項目依賴詳細清單，因此我們一般不用修改它，只需要對著Cargo.toml文件就行了。

### package配置

package中記錄了項目的描述信息如:

{% highlight rust %}

[package]
name = "world_hello"
version = "0.1.0"
edition = "2021"

{% endhighlight %}

name定義了項目名稱，version定義當前版本，新項目是0.1.0，edition字段定義了我們使用的Rust大版本。

### 定義項目依賴

使用cargo工具最大優勢在於，能夠對該項目的各種依賴項進行方便,統一和靈活的管理。

在Cargo.toml中，主要通過各種依賴段落來描述該項目的各種依賴項:

🛡 基於Rust官方crates.io，通過版本來書名描述

🛡 基於項目源代碼的git，通過url來描述

🛡 基於本地項目的絕對路徑或者相對路徑，通過對Unix模式路徑來描述

這三種具體寫法:

```
  [dependencies]
    rand = "0.3"
    hammer = { version = "0.5.0"}
    color = { git = "https://github.com/bjz/color-rs" }
    geometry = { path = "crates/geometry" }
```



